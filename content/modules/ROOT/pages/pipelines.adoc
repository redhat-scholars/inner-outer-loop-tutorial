# Workshop Development - Pipelines

In this section, you will learn how to use a Tekton pipeline resource and trigger the pipeline to run, and you'll be working with two common pipelines in this workshop.

- The first pipeline will clone the git repository source code of the `vote-api` and `vote-ui` repositories. The pipeline will then build the application and push the image to the internal image registry. You may notice there are already triggers in the development projects to notice when a commit is made to the Git repository, and restart the pipeline process automatically. Finally, the pipeline will update the deployment manifests in the `vote-api-gitops` and `vote-ui-gitops` repositories with the new image, and deploy the containers to the development environment.
- The second pipeline is for when our changes have been applied and tested, and the application is now ready to move from a development to production environment. The image and tag is copied for the application to be managed by Argo CD in a GitOps methodology to then control our cluster through the `vote-api-gitops` and `vote-ui-gitops` repositories scaffolded by Developer Hub in the previous step.

## Viewing the pipelines

From the Developer Hub `vote-api-{user}` component, we can view the native mapping of the Tekton plugin on Developer Hub to the *Pipelines* dashboard within the OpenShift Web Console.

img

NOTE: You can also navigate from the OpenShift Web Console to view the pipelines created for you. Within the *Developer* perspective of the OpenShift Console, click on the *Pipelines* link in the left navigation menu. You can also use link:https://console-openshift-console.%SUBDOMAIN%/dev-pipelines/all-namespaces[*this link*,role='params-link',window='_blank'] to head to the Pipelines page directly.

// Fix the above link

image::switch-perspective.png[]

Here, we will be in the `vote-app-dev-{user}` project, where the pipelines have been created. This section details all the pipelines we'll be using in the workshop, two for building the source code and deploying the container images to development, and two for promoting our application from the development to production environment. You can also view details about the last pipeline run, the status of the tasks, and more relevant details about the Pipeline.

img

Before we start the pipelines, let's look at one of the pipeline contents. Click on the `vote-api-builda` pipeline to view the pipeline details. Select *YAML* to view the pipeline definition in link:https://www.redhat.com/en/topics/automation/what-is-yaml[*YAML format*,window='_blank']. You should see the pipeline definition, along with the tasks that are defined in the Pipeline.

img

This Pipeline YAML defines the tasks to be run in the Pipeline and also defines the parameters used in the Pipeline, such as the git repository URL, the image name, and more. 

img

NOTE: We can also view the pipeline content below. For redundancy, we'll just be showing the `vote-api` pipeline manifests here. Feel free to explore and view the other `vote-ui` manifests from your environment.

*vote-api-build*

[%collapsible]
====
[.console-input]
[source,yaml]
----
apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
  name: vote-app-api-pipeline
  namespace: vote-app-ci-%USERID%
spec:
  params:
  - name: SOURCE_GIT_URL
    type: string
    description: The application git repository url
    default: 'http://gitea.gitea.svc:3000/%USERID%/pipelines-vote-api'
  - name: SOURCE_GIT_REVISION
    type: string
    default: master
    description: The application git repository revision
  - default: image-registry.openshift-image-registry.svc:5000/vote-app-dev-%USERID%/vote-api
    name: IMAGE_NAME
    type: string
  - default: .
    name: PATH_CONTEXT
    type: string
  - default: 'http://gitea.gitea.svc:3000/%USERID%/vote-app-gitops'
    name: CONFIG_GIT_REPO
    type: string
  - default: main
    name: CONFIG_GIT_REVISION
    type: string

  workspaces:
  - name: app-source

  tasks:

  - name: git-clone
    taskRef:
      kind: ClusterTask
      name: git-clone
    params:
    - name: url
      value: $(params.SOURCE_GIT_URL)
    - name: revision
      value: $(params.SOURCE_GIT_REVISION)
    - name: deleteExisting
      value: 'true'
    workspaces:
    - name: output
      workspace: app-source

  - name: build-and-push
    params:
    - name: IMAGE
      value: $(params.IMAGE_NAME)
    - name: TLSVERIFY
      value: "false"
    - name: CONTEXT
      value: $(params.PATH_CONTEXT)
    runAfter:
    - git-clone
    taskRef:
      kind: ClusterTask
      name: buildah
    workspaces:
    - name: source
      workspace: app-source

  - name: git-update-deployment
    params:
    - name: GIT_REPOSITORY
      value: $(params.CONFIG_GIT_REPO)
    - name: CURRENT_IMAGE
      value: quay.io/bluesman/vote-api:latest
    - name: NEW_IMAGE
      value: $(params.IMAGE_NAME)
    - name: NEW_DIGEST
      value: $(tasks.build-and-push.results.IMAGE_DIGEST)
    - name: KUSTOMIZATION_PATH
      value: environments/dev
    - name: GIT_REF
      value: $(params.CONFIG_GIT_REVISION)
    runAfter:
      - build-and-push
    taskRef:
      kind: Task
      name: git-update-deployment
    workspaces:
    - name: workspace
      workspace: app-source
----
====

*vote-api-promote*

[%collapsible]
====
[.console-input]
[source,yaml]
----
apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
  name: vote-app-ui-pipeline
  namespace: vote-app-ci-%USERID%
spec:
  params:
  - name: SOURCE_GIT_URL
    type: string
    description: The application git repository url
    default: 'http://gitea.gitea.svc:3000/%USERID%/pipelines-vote-ui'
  - name: SOURCE_GIT_REVISION
    type: string
    default: master
    description: The application git repository revision
  - default: image-registry.openshift-image-registry.svc:5000/vote-app-dev-%USERID%/vote-ui
    name: IMAGE_NAME
    type: string
  - default: .
    name: PATH_CONTEXT
    type: string
  - default: 'http://gitea.gitea.svc:3000/%USERID%/vote-app-gitops'
    name: CONFIG_GIT_REPO
    type: string
  - default: main
    name: CONFIG_GIT_REVISION
    type: string

  workspaces:
  - name: app-source

  tasks:

  - name: git-clone
    taskRef:
      kind: ClusterTask
      name: git-clone
    params:
    - name: url
      value: $(params.SOURCE_GIT_URL)
    - name: revision
      value: $(params.SOURCE_GIT_REVISION)
    - name: deleteExisting
      value: 'true'
    workspaces:
    - name: output
      workspace: app-source

  - name: build-and-push
    params:
    - name: IMAGE
      value: $(params.IMAGE_NAME)
    - name: TLSVERIFY
      value: "false"
    - name: CONTEXT
      value: $(params.PATH_CONTEXT)
    runAfter:
    - git-clone
    taskRef:
      kind: ClusterTask
      name: buildah
    workspaces:
    - name: source
      workspace: app-source

  - name: git-update-deployment
    params:
    - name: GIT_REPOSITORY
      value: $(params.CONFIG_GIT_REPO)
    - name: CURRENT_IMAGE
      value: quay.io/bluesman/vote-ui:latest
    - name: NEW_IMAGE
      value: $(params.IMAGE_NAME)
    - name: NEW_DIGEST
      value: $(tasks.build-and-push.results.IMAGE_DIGEST)
    - name: KUSTOMIZATION_PATH
      value: environments/dev
    - name: GIT_REF
      value: $(params.CONFIG_GIT_REVISION)
    runAfter:
      - build-and-push
    taskRef:
      kind: Task
      name: git-update-deployment
    workspaces:
    - name: workspace
      workspace: app-source
----
====

## Building and deploying the backend

Let's start these pipelines by using a link:https://tekton.dev/docs/pipelines/pipelineruns/[PipelineRun,window='_blank'], which is a custom resource that allows you to start a pipeline. This PipelineRun will start the `vote-api-build` pipeline, which will build the `vote-api` image from the GitLab source repository, and and push it to the local registry before deploying it to our development environment. If you haven't already, from the *Pipelines* view, select the `vote-api-build` pipeline.

NOTE: We're doing this step manually, however this would generally be automated as part of a software template in Developer Hub

img

Here, you can review the pipeline steps and see what each step is doing. You can also see the pipeline resources that are being used.

image::pipeline-details.png[]

For reference, here are the pipeline steps:

- `git-clone`: This step clones the local Git repository that contains the source code for the application. We're able to do so because of a `gitea-gitops` secret that was created for you. This secret contains the username and password to access the Gitea repository.
- `build-image`: This step builds the image and pushes it to the internal OpenShift registry. The image name is passed in as a parameter.
- `resync`: This final step updates the deployment manifests in the Git repository.

Now, let's start the Pipeline. Click on the top-right *Actions* then *Start* button to start the Pipeline.

img

You will be prompted to enter the values for the pipeline parameters, however the default values are already set for you. This includes the source Git repository, image name to build, and GitOps manifest repository.

img

You'll still need to select a workspace for storage, so scroll to the bottom of the form, select *VolumeClaimTemplate*. This link:https://kubernetes.io/docs/concepts/storage/persistent-volumes/[Volume Claim Template,window='_blank'] gives us persistent storage that the Pipeline can access even in a containerized environment. Now, click on the *Start* button.

img

Now that the `vote-api-build` pipeline has been started, we can view it in action from the *PipelineRuns* view. We'll need to wait for this first PipelineRun to finish before we can start the `vote-ui-app-pipeline` pipeline, which should take about 1-2 minutes, but we can continue on with the workshop.

img

In addition, there's a mapping of this same information in Developer Hub, so we wouldn't have to move between contexts in order to see information about this PipelineRun.

TIP: If you're curious, you can check the *Topology* of the `vote-app-dev-{user}` project to view the backend, it may be created already! We'll soon talk about all the different icons in the topology and what they represent.

## Building and deploying the frontend

With the `vote-api-build` PipelineRun in action or completed, we can now start the `vote-ui-build` pipeline. Let's repeat the same steps for this other Pipeline, first selecting it from the *Pipelines* view.

img

Here, we can go ahead and start the Pipeline. The tasks are essentially the same as the `vote-api-build`, so we can click the top-right *Actions* then *Start* button to start the Pipeline.

img

You'll notice that the only change here is the difference in the source Git repository and image name to build.

img

Although the default values are already set for you, you'll still need to select a workspace for storage, so select *VolumeClaimTemplate*. Now, click on the *Start* button.

img

With the `vote-ui-build` pipeline started, let's go ahead and check the status of this Pipeline. We should be at the *PipelineRuns* view, and after a minute or two, the `vote-ui-app-pipeline` PipelineRun should be completed, or we could view this from Developer Hub.

## Checking the status of the pipelines

From the *PipelineRuns* section, we can examine various details about the specific PipelineRun, such as the YAML executed, each TaskRun executed, parameters used for the PipelineRun, and logs from each Task.

img

For example, viewing the logs from the `build-image` Task, we can see the output from the _build_ and _push_ actions, which use the link:https://buildah.io/[Buildah,window='_blank'] `bud` command.

img

## Checking the status of the applications

Now that the pipelines have finished, let's check the status of the deployments. Click on the *Topology* left-hand tab to see the list of deployments that have been created in the `vote-app-dev-{user}` project. We now have a new application called *Triggers* which contains two deployments, one for the `vote-api` and one for the `vote-ui`, which listen for changes in the source repositories to rebuild and redeploy the applications in this environment. More importantly, however, are the two new microservices that have been built and deployed from our source code.

img

Feel free to click on a deployment to view the details, including the pods that are running, but the little arrow on the top right of the icon will open the *Route*, in order to view the application in our browser. Select the *Route* of the `vote-ui` (Python icon) to open up the frontend of our application.

img

////
## Start `vote-ui` with a Webhook

Tekton supports link:https://tekton.dev/docs/triggers/[Triggers,window='_blank'] to enable automation and webhooks. Now that the `vote-ui` deployment is running, let's add a webhook to the Gitea repository to trigger a new build of the application when changes are made to the repository. From the *Topology* view, click on the `el-eventlistener-ui` deployment. From there, navigate to the *Routes* section and copy the `el-eventlistener-ui` Route URL from the bottom right-hand corner.

image::trigger-vote-ui.png[Trigger Vote UI]

Once you have the URL copied to your clipboard, navigate to the `pipelines-vote-ui` code repository that you have on link:https://gitea.%SUBDOMAIN%/%USERID%/pipelines-vote-ui[*Gitea*,role='params-link',window='_blank']. From your repository page, click on the Settings menu in the top-right corner. From the top right-side menu, click on *Settings*, then *Webhooks*. Then, click on *Add Webhook* from the right-side menu.

image::add-webhook.png[Add Webhook]

Paste the copied Route URL into the *Target URL* field in the next screen. You can leave the other fields blank; just ensure the Content Type is set to `application/json`. Finally, click on *Add Webhook* to create the webhook.

image::create-webhook.png[Create Webhook]

Great, now we have a webhook that will trigger a new build of the application when changes are made to the Git repository. Later on in this module, we'll make some changes to the source code using OpenShift Dev Spaces and push the changes to the Git repository to trigger a new build.
////

## Promoting the applications to production

While these applications are running just fine in the development project, what if we'd like to promote our applications to production? Let's learn how to do this now, as once we make changes to the source code and rebuild our application later, we'll end up promoting the applications to production again. First, return to the *Pipelines* dashboard to view the `vote-api-promote` and `vote-ui-promote` pipelines.

img

Let's start the pipelines, first the `vote-api-promote`. Click on the top-right *Actions* then *Start* button to start the Pipeline.

img

You will be prompted to enter the values for the pipeline parameters, however the default values are already set for you. This includes the source Git repository and details, as well as the Argo CD host to update the image tag. Hit the *Start* button again to kick off the process.

img

As the end goal of our workshop is to bring our application into production, please repeat the same steps we've just done for the `vote-ui-promote`, the steps will be the same. When finished, we can take a look at the final result in the OpenShift topology and on the Developer Hub, and proceed to work from the initial project creation.

## Viewing the application in production

Now that the pipelines have finished moving our application from development to production, let's check the status of the deployments. Click on the *Topology* left-hand tab to see the list of deployments that have been created in the `vote-app-prod-{user}` project.

img

Here, we can just see both of the microservices deployed in our production environment.

img

In addition, from either the `vote-api` or `vote-ui` components in Developer Hub, we can view the *Topology* plugin to view all instances of the component in our cluster, both in the development and production environment.

img

## Next Steps

Congratulations! You've successfully deployed the `vote-api` and `vote-ui` to the deployment environment using Tekton Pipelines. Now, let's move on to the next lab to learn how to deploy the application using Argo CD.

////
## For later (cedric to fix)

## Examining the CI/CD Pipeline

Developer Hub automatically sets up a continuous integration and deployment (CI/CD) pipeline for each component. The pipeline is responsible for building, testing, and deploying the component whenever changes are pushed to the source code repository.

Navigate to the *CI/CD* tab on the component details page in Developer Hub to view the pipeline status and details.

image::developer-hub-vote-api-cicd.png[Developer Hub Vote API CI/CD]

Click on the pipeline to view its details, including the pipeline stages, logs, and any associated artifacts.

image::developer-hub-vote-api-cicd-details.png[Developer Hub Vote API CI/CD Details]

You can also view the pipeline definition file (e.g., Jenkinsfile) in the source code repository to understand how the pipeline is configured.

Repeat the same process for the `vote-ui` component and examine its CI/CD pipeline.
////